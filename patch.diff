diff --git a/Synctube/.gitignore b/Synctube/.gitignore
new file mode 100644
index 0000000..ba16d60
--- /dev/null
+++ b/Synctube/.gitignore
@@ -0,0 +1,38 @@
+# From https://github.com/github/gitignore/blob/8209359a888a31b1fd94a4e5ef0524ea6b61e25c/Node.gitignore
+
+lib-cov
+lcov.info
+*.seed
+*.log
+*.csv
+*.dat
+*.out
+*.pid
+*.gz
+
+pids
+logs
+results
+build
+.grunt
+
+node_modules
+
+# VS2013 files
+
+.gitattributes
+*.suo
+*.njsproj
+
+# Build tools
+
+bower_components
+
+# Generated files
+
+static/*.js*
+static/*.css*
+
+# Environment
+
+.env
diff --git a/Synctube/LICENSE.txt b/Synctube/LICENSE.txt
new file mode 100644
index 0000000..adc297c
--- /dev/null
+++ b/Synctube/LICENSE.txt
@@ -0,0 +1,2 @@
+Copyright Â© Henry Merriam, 2014
+All rights reserved.
diff --git a/Synctube/Procfile b/Synctube/Procfile
new file mode 100644
index 0000000..4154ce2
--- /dev/null
+++ b/Synctube/Procfile
@@ -0,0 +1 @@
+web: node .
\ No newline at end of file
diff --git a/Synctube/README.md b/Synctube/README.md
new file mode 100644
index 0000000..9341a8e
--- /dev/null
+++ b/Synctube/README.md
@@ -0,0 +1,4 @@
+Synctube
+========
+
+Realtime web video synchronization.
diff --git a/Synctube/bower.json b/Synctube/bower.json
new file mode 100644
index 0000000..5cd2984
--- /dev/null
+++ b/Synctube/bower.json
@@ -0,0 +1,8 @@
+{
+	"name": "synctube",
+	"dependencies": {
+		"octicons": "^2.4.1",
+		"bootswatch": "^3.0.0"
+	},
+	"private": true
+}
\ No newline at end of file
diff --git a/Synctube/client/browse.js b/Synctube/client/browse.js
new file mode 100644
index 0000000..0efda70
--- /dev/null
+++ b/Synctube/client/browse.js
@@ -0,0 +1,29 @@
+/**
+ * Module dependencies.
+ */
+
+var domready = require('domready');
+var ko = require('knockout');
+
+/**
+ * Browse view model.
+ */
+
+function BrowseViewModel () {
+	var self = this;
+	self.name = ko.observable('');
+	self.create = function () {
+		var name = encodeURIComponent(self.name());
+		if (name) {
+			window.location.pathname = '/rooms/' + name;
+		}
+	};
+}
+
+/**
+ * Apply Knockout bindings.
+ */
+
+domready(function () {
+	ko.applyBindings(new BrowseViewModel());
+});
diff --git a/Synctube/client/controls.js b/Synctube/client/controls.js
new file mode 100644
index 0000000..7ed7064
--- /dev/null
+++ b/Synctube/client/controls.js
@@ -0,0 +1,31 @@
+/**
+ * Module dependencies.
+ */
+
+var ko = require('knockout');
+var moment = require('moment');
+var sync = require('./sync');
+
+/**
+ * Controls view model.
+ */
+
+module.exports = exports = new (function () {
+	var self = this;
+	self.seek = function () {
+		sync.seek(moment.duration(self.seekTime()).asSeconds());
+	};
+	self.seekTime = ko.observable('');
+	self.playpause = function () {
+		if (self.playing()) {
+			sync.pause();
+		} else {
+			sync.play();
+		}
+	};
+	self.playing = ko.observable(false);
+	sync.state.on('state', function () {
+		var state = sync.state.getState();
+		self.playing(state.playing);
+	});
+})();
diff --git a/Synctube/client/player.js b/Synctube/client/player.js
new file mode 100644
index 0000000..16a12ec
--- /dev/null
+++ b/Synctube/client/player.js
@@ -0,0 +1,75 @@
+/**
+ * Module dependencies.
+ */
+
+var events = require('events');
+
+/**
+ * YouTube player.
+ */
+
+var tag = document.createElement('script');
+tag.src = 'https://www.youtube.com/iframe_api';
+var firstScriptTag = document.getElementsByTagName('script')[0];
+firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
+
+var youtube;
+window.onYouTubeIframeAPIReady = function () {
+	youtube = new YT.Player('player', {
+		playerVars: {
+			rel: 0,
+			showinfo: 0,
+		},
+		events: {
+			'onReady': onPlayerReady,
+			'onStateChange': onPlayerStateChange,
+		},
+	});
+};
+
+function onPlayerReady (event) {
+	player.emit('ready');
+}
+
+function onPlayerStateChange (event) {
+	player.emit('change');
+}
+
+/**
+ * Player module interface.
+ */
+
+var player = module.exports = exports = {
+	play: function () {
+		youtube.playVideo();
+	},
+	pause: function () {
+		youtube.pauseVideo();
+	},
+	seek: function (time) {
+		youtube.seekTo(time + (this.isPlaying() ? 0.5 : 0), true);
+	},
+	load: function (video, time) {
+		youtube.loadVideoById(video.id, time);
+	},
+	getVideo: function () {
+		var data = youtube.getVideoData();
+		return data ? data.video_id : null;
+	},
+	getTime: function () {
+		return youtube.getCurrentTime();
+	},
+	isPlaying: function () {
+		return youtube.getPlayerState() === YT.PlayerState.PLAYING;
+	},
+	isEnded: function () {
+		return youtube.getPlayerState() === YT.PlayerState.ENDED;
+	},
+};
+
+/**
+ * Extend EventEmitter.
+ */
+
+player.__proto__ = events.EventEmitter.prototype;
+events.EventEmitter.call(player);
diff --git a/Synctube/client/playlist.js b/Synctube/client/playlist.js
new file mode 100644
index 0000000..b759e00
--- /dev/null
+++ b/Synctube/client/playlist.js
@@ -0,0 +1,93 @@
+/**
+ * Module dependencies.
+ */
+
+var ko = require('knockout');
+var moment = require('moment');
+var sync = require('./sync');
+var youtube = require('../lib/youtube');
+
+require('moment-duration-format');
+
+/**
+ * Duration formatting.
+ */
+
+function formatDuration (d) {
+	return d.format(d.asHours() < 1 ? 'm:ss' : 'h:mm:ss', { trim: false });
+}
+
+/**
+ * ViewModel for an individual playlist entry.
+ */
+
+function PlaylistEntryViewModel(entry) {
+	var self = this;
+
+	var key = self.key = entry.key;
+	var videoId = entry.value.id;
+	var length = entry.value.length;
+
+	self.title = ko.observable();
+	self.length = formatDuration(moment.duration(length, 'seconds'));
+	self.thumbnail = ko.observable();
+
+	self.isCurrent = ko.computed(function () {
+		return key == playlist.currentKey();
+	});
+
+	self.play = function () {
+		sync.cue(key);
+	};
+
+	self.remove = function () {
+		sync.remove(key);
+	};
+
+	self.moveUp = function () {
+		var before = sync.playlist.before(key);
+		sync.move(key, before);
+	};
+
+	youtube.getVideoSnippet(videoId, function (err, item) {
+		if (err) { return; }
+		self.title(item.title);
+		self.thumbnail(item.thumbnails.default.url);
+	});
+}
+
+/**
+ * Observe sync playlist and map it to playlist entry view models.
+ */
+
+var entries = sync.playlist.map(function (key, value) { return new PlaylistEntryViewModel({ key: key, value: value }); }).collect();
+
+/**
+ * Observe mapped playlist and update Knockout observable.
+ */
+
+function updatePlaylist () {
+	playlist.entries(entries.getValues());
+}
+
+entries.on('clear', updatePlaylist);
+entries.on('put', updatePlaylist);
+entries.on('move', updatePlaylist);
+entries.on('remove', updatePlaylist);
+
+/**
+ * Playlist view model.
+ */
+
+var playlist = module.exports = exports = new (function () {
+	var self = this;
+	self.entries = ko.observableArray();
+	self.currentKey = ko.observable(null);
+	sync.state.on('state', function () {
+		var state = sync.state.getState();
+		self.currentKey(state.key || null);
+	});
+	self.shuffle = function () {
+		sync.shuffle();
+	};
+})();
diff --git a/Synctube/client/room.js b/Synctube/client/room.js
new file mode 100644
index 0000000..bd3c81f
--- /dev/null
+++ b/Synctube/client/room.js
@@ -0,0 +1,29 @@
+/**
+ * Module dependencies.
+ */
+
+var domready = require('domready');
+var ko = require('knockout');
+var controls = require('./controls');
+var playlist = require('./playlist');
+var search = require('./search');
+var users = require('./users');
+
+/**
+ * Room ViewModel.
+ */
+
+var room = module.exports = exports = {
+	controls: controls,
+	playlist: playlist,
+	search: search,
+	users: users,
+};
+
+/**
+ * Apply Knockout bindings.
+ */
+
+domready(function () {
+	ko.applyBindings(room);
+});
diff --git a/Synctube/client/search.js b/Synctube/client/search.js
new file mode 100644
index 0000000..e928c4a
--- /dev/null
+++ b/Synctube/client/search.js
@@ -0,0 +1,82 @@
+/**
+ * Module dependencies.
+ */
+
+var ko = require('knockout');
+var moment = require('moment');
+var sync = require('./sync');
+var youtube = require('../lib/youtube');
+
+require('moment-duration-format');
+
+/**
+ * Duration formatting.
+ */
+
+function formatDuration (d) {
+	return d.format(d.asHours() < 1 ? 'm:ss' : 'h:mm:ss', { trim: false });
+}
+
+/** 
+ * ViewModel for a search result.
+ */
+
+function SearchResultViewModel (result) {
+	var self = this;
+	var videoId = result.item.id.videoId;
+
+	self.length = formatDuration(moment.duration(result.length, 'seconds'));
+	self.title = result.item.snippet.title;
+	self.thumbnail = result.item.snippet.thumbnails.default.url;
+
+	self.add = function () {
+		sync.add(videoId);
+	};
+}
+
+/**
+ * Search view model.
+ */
+
+module.exports = exports = new (function () {
+	var self = this;
+	self.link = ko.observable('');
+	self.results = ko.observableArray();
+	self.add = function () {
+		var query = self.link();
+		if (query == '') {
+			self.results([]);
+			return;
+		}
+		self.link('');
+		var id = youtube.parseUrl(query);
+		if (id === null) {
+			self.lastQuery(query);
+			youtube.search(query, _searchResult);
+		} else {
+			sync.add(id);
+		}
+	};
+	self.lastQuery = ko.observable();
+	self.prevToken = ko.observable();
+	self.nextToken = ko.observable();
+	self.prevDisabled = ko.computed(function () { return self.prevToken() == null; });
+	self.nextDisabled = ko.computed(function () { return self.nextToken() == null; });
+	self.prev = function () {
+		if (self.prevToken()) {
+			youtube.searchPage(self.lastQuery(), self.prevToken(), _searchResult);
+		}
+	};
+	self.next = function () {
+		if (self.nextToken()) {
+			youtube.searchPage(self.lastQuery(), self.nextToken(), _searchResult);
+		}
+	};
+
+	function _searchResult (err, results) {
+		if (err) { alert(JSON.stringify(err)); return; }
+		self.prevToken(results.prevToken);
+		self.nextToken(results.nextToken);
+		self.results(results.items.map(function (result) { return new SearchResultViewModel(result); }));
+	}
+})();
diff --git a/Synctube/client/sync.js b/Synctube/client/sync.js
new file mode 100644
index 0000000..f95b01f
--- /dev/null
+++ b/Synctube/client/sync.js
@@ -0,0 +1,177 @@
+/**
+ * Module dependencies.
+ */
+
+var io = require('socket.io-client');
+var player = require('./player');
+var LinkedMap = require('../lib/linkedmap');
+var Simulation = require('../lib/simulation');
+var EventEmitter = require('events').EventEmitter;
+var util = require('util');
+
+/**
+ * Local playlist and state simulation.
+ */
+
+var playlist = new LinkedMap();
+var simulation = new Simulation(playlist);
+
+/**
+ * Establish socket connection.
+ */
+
+var socket = io();
+
+socket.on('connect', function () {
+
+	/**
+	 * Synchronize local playlist with the remote.
+	 */
+
+	socket.on('playlist', function (entries) {
+		playlist.clear();
+		entries.forEach(function (entry) {
+			playlist.put(entry.key, entry.value);
+		});
+	});
+
+	socket.on('clear', function () {
+		playlist.clear();
+	});
+
+	socket.on('put', function (key, value) {
+		playlist.put(key, value);
+	});
+
+	socket.on('move', function (key, before) {
+		playlist.move(key, before);
+	});
+
+	socket.on('remove', function (key) {
+		playlist.remove(key);
+	});
+
+	/**
+	 * Synchronize local state with remote state updates.
+	 */
+
+	socket.on('state', function (state) {
+		simulation.setState(state);
+	});
+
+	/**
+	 * Emit user count updates.
+	 */
+
+	socket.on('users', function (count) {
+		sync.emit('users', count);
+	});
+
+	/**
+	 * Join room.
+	 */
+
+	var name = decodeURIComponent(window.location.pathname.split('/')[2]);
+	socket.emit('join', name);
+
+});
+
+/**
+ * Synchronize player with local state.
+ */
+
+player.on('ready', function () {
+
+	function updatePlayer (state) {
+
+		if (state.key == null) {
+			player.pause();
+			player.load({ id: null }, 0);
+			return;
+		}
+
+		var video = playlist.get(state.key);
+
+		if (player.getVideo() != video.id) {
+			player.load(video, state.offset);
+		} else {
+			if (Math.abs(player.getTime() - state.offset) > 1) {
+				player.seek(state.offset + 0.25);
+			}
+		}
+
+		if (player.isPlaying() != state.playing) {
+			if (state.playing) {
+				player.play();
+			} else {
+				player.pause();
+			}
+		}
+	}
+
+	function fetchAndUpdate() {
+		var state = simulation.getState();
+		updatePlayer(state);
+	}
+
+	simulation.on('state', updatePlayer);
+
+	var _poll = setInterval(fetchAndUpdate, 1000);
+
+	player.on('change', function () {
+		if (_poll != null) {
+			clearInterval(_poll);
+			_poll = null;
+		}
+		fetchAndUpdate();
+	});
+
+	updatePlayer(simulation.getState());
+
+});
+
+/**
+ * Sync module interface.
+ */
+
+function Sync () {
+	EventEmitter.call(this);
+	this.playlist = playlist;
+	this.state = simulation;
+}
+
+util.inherits(Sync, EventEmitter);
+
+Sync.prototype.cue = function (key) {
+	socket.emit('cue', key);
+};
+
+Sync.prototype.remove = function (key) {
+	socket.emit('delete', key);
+};
+
+Sync.prototype.add = function (id) {
+	socket.emit('add', id);
+};
+
+Sync.prototype.move = function (key, beforeKey) {
+	socket.emit('move', key, beforeKey);
+};
+
+Sync.prototype.shuffle = function () {
+	socket.emit('shuffle');
+};
+
+Sync.prototype.seek = function (time) {
+	socket.emit('seek', time);
+};
+
+Sync.prototype.play = function () {
+	socket.emit('play');
+};
+
+Sync.prototype.pause = function () {
+	socket.emit('pause');
+};
+
+var sync = module.exports = exports = new Sync();
diff --git a/Synctube/client/users.js b/Synctube/client/users.js
new file mode 100644
index 0000000..59062ad
--- /dev/null
+++ b/Synctube/client/users.js
@@ -0,0 +1,18 @@
+/**
+ * Module dependencies.
+ */
+
+var ko = require('knockout');
+var sync = require('./sync');
+
+/**
+ * Users view model.
+ */
+
+module.exports = exports = new (function () {
+	var self = this;
+	self.count = ko.observable();
+	sync.on('users', function (count) {
+		self.count(count);
+	})
+})();
diff --git a/Synctube/config-client.js b/Synctube/config-client.js
new file mode 100644
index 0000000..72c1476
--- /dev/null
+++ b/Synctube/config-client.js
@@ -0,0 +1,11 @@
+/**
+ * Module exports.
+ */
+
+module.exports = exports = {
+	youtube: {
+		apiKey: process.env.SYNCTUBE_CLIENT_YOUTUBE_APIKEY,
+		batchDelay: parseInt(process.env.SYNCTUBE_YOUTUBE_BATCH_DELAY),
+		batchLimit: parseInt(process.env.SYNCTUBE_YOUTUBE_BATCH_LIMIT),
+	},
+};
diff --git a/Synctube/config.js b/Synctube/config.js
new file mode 100644
index 0000000..bec79d9
--- /dev/null
+++ b/Synctube/config.js
@@ -0,0 +1,14 @@
+/**
+ * Module exports.
+ */
+
+module.exports = exports = {
+	listen: {
+		port: process.argv[2] || process.env.PORT,
+	},
+	youtube: {
+		apiKey: process.env.SYNCTUBE_SERVER_YOUTUBE_APIKEY,
+		batchDelay: parseInt(process.env.SYNCTUBE_YOUTUBE_BATCH_DELAY),
+		batchLimit: parseInt(process.env.SYNCTUBE_YOUTUBE_BATCH_LIMIT),
+	},
+};
diff --git a/Synctube/less/brand.less b/Synctube/less/brand.less
new file mode 100644
index 0000000..c1d8cb2
--- /dev/null
+++ b/Synctube/less/brand.less
@@ -0,0 +1,18 @@
+@synctube-brand: #14a;
+
+.navbar-brand {
+	font-size: @font-size-large * 1.2;
+	text-transform: lowercase;
+
+	.highlight {
+		background-color: @synctube-brand;
+		margin: 0 (0.1em);
+		padding: 0 (0.25em);
+		.border-top-radius(0.4em);
+		.border-bottom-radius(0.3em);
+	}
+
+	.muted {
+		color: @gray;
+	}
+}
diff --git a/Synctube/less/main.less b/Synctube/less/main.less
new file mode 100644
index 0000000..1561026
--- /dev/null
+++ b/Synctube/less/main.less
@@ -0,0 +1,21 @@
+@import 'bootstrap/less/bootstrap.less';
+@import 'bootswatch/cyborg/variables.less';
+@import 'bootswatch/cyborg/bootswatch.less';
+@import 'bootstrap/less/utilities.less';
+
+@icon-font-path: '//netdna.bootstrapcdn.com/bootstrap/3.0.3/fonts/';
+
+@gray-even-darker: #181818;
+
+@import 'brand.less';
+@import 'navbar.less';
+@import 'playlist.less';
+
+@screen-lg: 1600px;
+@screen-md: 1200px;
+@screen-sm: 900px;
+@screen-xs: 600px;
+
+@import 'octicons/octicons/octicons.less';
+
+@octicons-font-path: 'https://cdnjs.cloudflare.com/ajax/libs/octicons/2.4.1';
diff --git a/Synctube/less/navbar.less b/Synctube/less/navbar.less
new file mode 100644
index 0000000..7604aab
--- /dev/null
+++ b/Synctube/less/navbar.less
@@ -0,0 +1,11 @@
+@navbar-default-link-hover-bg: @gray-even-darker;
+@navbar-default-link-active-bg: @gray-even-darker;
+@navbar-default-brand-hover-bg: @gray-even-darker;
+
+@navbar-border-radius: 0;
+
+.navbar {
+	border-left: none;
+	border-right: none;
+	border-top: none;
+}
diff --git a/Synctube/less/playlist.less b/Synctube/less/playlist.less
new file mode 100644
index 0000000..aed5221
--- /dev/null
+++ b/Synctube/less/playlist.less
@@ -0,0 +1,27 @@
+.playlist-thumb {
+
+	position: relative;
+
+	.timestamp {
+		position: absolute;
+		right: 2px;
+		bottom: 2px;
+	}
+
+	img {
+		width: 80px;
+		height: 60px;
+	}
+
+}
+
+.playlist-item-buttons {
+	display: table-cell;
+	padding-right: 10px;
+	width: 34px;
+}
+
+.playlist-item-title {
+	overflow: hidden;
+	height: 60px;
+}
diff --git a/Synctube/lib/linkedmap.js b/Synctube/lib/linkedmap.js
new file mode 100644
index 0000000..0e541f5
--- /dev/null
+++ b/Synctube/lib/linkedmap.js
@@ -0,0 +1,288 @@
+/**
+ * Module dependencies.
+ */
+
+var ObservableMap = require('./observablemap');
+var util = require('util');
+
+/**
+ * Module exports.
+ */
+
+module.exports = exports = LinkedMap;
+
+/**
+ * Key/value collection supporting fast insert, lookup, move and delete operations.
+ */
+
+function LinkedMap () {
+	ObservableMap.call(this);
+	this.head = this.tail = this;
+	this.entries = {};
+	this.key = null;
+}
+
+/**
+ * Extend ObservableMap.
+ */
+
+util.inherits(LinkedMap, ObservableMap);
+
+/**
+ * Returns the first key in the list, or null if the list is empty.
+ */
+
+LinkedMap.prototype.first = function () {
+	return this.head.key;
+};
+
+/**
+ * Returns the last key in the list, or null if the list is empty.
+ */
+
+LinkedMap.prototype.last = function () {
+	return this.tail.key;
+};
+
+/**
+ * Returns the key before the given key, or null if that key is the first.
+ */
+
+LinkedMap.prototype.before = function (key) {
+	var node = this.entries[key];
+	if (!node) {
+		return undefined;
+	}
+	return node.tail.key;
+};
+
+/**
+ * Returns the key after the given key, or null if that key is the last.
+ */
+
+LinkedMap.prototype.after = function (key) {
+	var node = this.entries[key];
+	if (!node) {
+		return undefined;
+	}
+	return node.head.key;
+};
+
+/**
+ * Returns the value associated with the given key, or null if there is none.
+ */
+
+LinkedMap.prototype.get = function (key) {
+	var node = this.entries[key];
+	return node ? node.value : null;
+};
+
+/**
+ * Returns the node associated with the given key, or null if there is none.
+ */
+
+LinkedMap.prototype.getNode = function (key) {
+	var node = this.entries[key];
+	return node ? _clone(node) : null;
+};
+
+/**
+ * Returns an array of all values.
+ */
+
+LinkedMap.prototype.getValues = function () {
+	var array = [];
+	this.forEach(function (node) {
+		array.push(node.value);
+	});
+	return array;
+};
+
+/**
+ * Returns an array of all keys.
+ */
+
+LinkedMap.prototype.getKeys = function () {
+	var array = [];
+	this.forEach(function (node) {
+		array.push(node.key);
+	});
+	return array;
+};
+
+/**
+ * Returns an array of all nodes.
+ */
+
+LinkedMap.prototype.getNodes = function () {
+	var array = [];
+	this.forEach(function (node) {
+		array.push(node);
+	});
+	return array;
+};
+
+/**
+ * Clears the list.
+ */
+
+LinkedMap.prototype.clear = function () {
+	this.head = this.tail = this;
+	this.entries = {};
+	this.emit('clear');
+	return this;
+};
+
+/**
+ * Associates a value with a key, updating the key if it already exists.
+ */
+
+LinkedMap.prototype.put = function (key, value) {
+	if (key == null) {
+		return false;
+	}
+	var node = this.entries[key];
+	if (node) {
+		node.value = value;
+	} else {
+		node = _create(key, value);
+		_insert(node, this);
+		this.entries[key] = node;
+	}
+	this.emit('put', key, value);
+	return true;
+};
+
+/**
+ * Inserts a node immediately before another node.
+ */
+
+function _insert (entry, before) {
+	entry.head = before;
+	entry.tail = before.tail;
+	entry.head.tail = entry.tail.head = entry;
+}
+
+/**
+ * Inserts a value with a random key. Returns the key used.
+ */
+
+LinkedMap.prototype.push = function (value) {
+	var key;
+	var i = 0;
+	do {
+		if (i++ > 20) {
+			throw new Error('keyspace exhausted');
+		}
+		key = Math.floor(Math.random() * 0xFFFFFFFF);
+	} while (this.entries[key]);
+	this.put(key, value);
+	return key;
+};
+
+/**
+ * Removes a key and its associated value from the list. Returns the removed value, or null if the key was not found.
+ */
+
+LinkedMap.prototype.remove = function (key) {
+	var node = this.entries[key];
+	if (!node) {
+		return null;
+	}
+	_remove(node);
+	delete this.entries[key];
+	this.emit('remove', key);
+	return node.value;
+};
+
+/**
+ * Extracts a node from the list.
+ */
+
+function _remove (entry) {
+	entry.head.tail = entry.tail;
+	entry.tail.head = entry.head;
+	entry.head = entry.tail = null;
+}
+
+/**
+ * Moves a key immediately before another key.
+ */
+
+LinkedMap.prototype.move = function (key, before) {
+	var node = this.entries[key];
+	if (!node) {
+		return false;
+	}
+	var beforeNode = this;
+	if (before) {
+		beforeNode = this.entries[before];
+		if (!beforeNode) {
+			return false;
+		}
+	}
+	if (node.head !== beforeNode) {
+		_remove(node);
+		_insert(node, beforeNode);
+		this.emit('move', key, beforeNode.key);	
+	}
+	return true;
+};
+
+/**
+ * Invokes a function for each node in the list.
+ * 
+ * Aborts iteration if the function returns true. Returns whether iteration was aborted.
+ */
+
+LinkedMap.prototype.forEach = function (f) {
+	var node = this.head;
+	var i = 0;
+	while (node !== this) {
+		if (f(_clone(node), i++)) {
+			return true;
+		}
+		node = node.head;
+	}
+	return false;
+};
+
+/**
+ * Creates a node with the given key and value.
+ */
+
+function _create (key, value) {
+	return {
+		key: key,
+		value: value,
+	};
+}
+
+/**
+ * Clones a node.
+ */
+
+function _clone (node) {
+	return _create(node.key, node.value);
+}
+
+/**
+ * Creates a linked map reflecting an observable collection's changes.
+ */
+
+ObservableMap.prototype.collect = function () {
+	var map = new LinkedMap();
+	this.on('clear', function () {
+		map.clear(); 
+	});
+	this.on('put', function (key, value) {
+		map.put(key, value);
+	});
+	this.on('move', function (key, before) {
+		map.move(key, before);
+	});
+	this.on('remove', function (key) {
+		map.remove(key);
+	});
+	return map;
+};
diff --git a/Synctube/lib/observablemap.js b/Synctube/lib/observablemap.js
new file mode 100644
index 0000000..399074c
--- /dev/null
+++ b/Synctube/lib/observablemap.js
@@ -0,0 +1,84 @@
+/**
+ * Module dependencies.
+ */
+
+var EventEmitter = require('events').EventEmitter;
+var util = require('util');
+
+/**
+ * Module exports.
+ */
+
+module.exports = exports = ObservableMap;
+
+/**
+ * Abstract observable collection supporting insert, move, delete and clear operations.
+ */
+
+function ObservableMap () {
+	EventEmitter.call(this);
+}
+
+/**
+ * Extend EventEmitter.
+ */
+
+util.inherits(ObservableMap, EventEmitter);
+
+/**
+ * Creates an observable map with projected values.
+ */
+
+ObservableMap.prototype.map = function (f) {
+	return new Projection(this, f);
+};
+
+function Projection (map, f) {
+	ObservableMap.call(this);
+	var self = this;
+	map.on('clear', function () {
+		self.emit('clear');
+	});
+	map.on('put', function (key, value) {
+		self.emit('put', key, f(key, value));
+	});
+	map.on('move', function (key, before) {
+		self.emit('move', key, before);
+	});
+	map.on('remove', function (key) {
+		self.emit('remove', key);
+	});
+}
+
+util.inherits(Projection, ObservableMap);
+
+/**
+ * Creates an observable map that emits a pre-event before all other events.
+ */
+
+ObservableMap.prototype.pre = function () {
+	return new Pre(this);
+};
+
+function Pre (map) {
+	ObservableMap.call(this);
+	var self = this;
+	map.on('clear', function () {
+		self.emit('pre');
+		self.emit('clear');
+	});
+	map.on('put', function (key, value) {
+		self.emit('pre');
+		self.emit('put', key, value);
+	});
+	map.on('move', function (key, before) {
+		self.emit('pre');
+		self.emit('move', key, before);
+	});
+	map.on('remove', function (key) {
+		self.emit('pre');
+		self.emit('remove', key);
+	});
+}
+
+util.inherits(Pre, ObservableMap);
diff --git a/Synctube/lib/simulation.js b/Synctube/lib/simulation.js
new file mode 100644
index 0000000..55853a5
--- /dev/null
+++ b/Synctube/lib/simulation.js
@@ -0,0 +1,126 @@
+/**
+ * Module dependencies.
+ */
+
+var EventEmitter = require('events').EventEmitter;
+var util = require('util');
+
+/**
+ * Module exports.
+ */
+
+module.exports = exports = Simulation;
+
+/**
+ * Simulates a playlist.
+ */
+
+function Simulation (source) {
+	EventEmitter.call(this);
+
+	var pre = source.pre();
+	this.playlist = pre.collect();
+	this._time = Date.now() / 1000;
+	this._state = {};
+	this._timeout = null;
+	this._prev = null;
+
+	var self = this;
+	pre.on('pre', function () {
+		self._updateState();
+	});
+}
+
+util.inherits(Simulation, EventEmitter);
+
+/**
+ * Retrieve latest state.
+ */
+
+Simulation.prototype.getState = function () {
+	this._updateState();
+	return this._state;
+};
+
+/**
+ * Replace simulation state with an external state.
+ */
+
+Simulation.prototype.setState = function (state) {
+	this._state = state;
+	this._time = Date.now() / 1000;
+	this._reschedule();
+	this.emit('state', state);
+};
+
+/**
+ * Advance simulation to the present.
+ */
+
+Simulation.prototype._updateState = function () {
+	var newTime = Date.now() / 1000;
+
+	if (newTime < this._time) {
+		newTime = this._time;
+	}
+
+	var elapsed = (newTime - this._time) + this._state.offset;
+	this._time = newTime;
+
+	if (!this._state.playing) {
+		return;
+	}
+
+	var key = this._state.key;
+	while (true) {
+		if (key == null) {
+			key = this.playlist.first();
+			if (key == null) {
+				this._state.key = null;
+				this._state.playing = false;
+				this._state.offset = 0;
+				break;
+			}
+		}
+		var video = this.playlist.get(key);
+		if (video == null) {
+			this._state.key = null;
+			this._state.playing = false;
+			this._state.offset = 0;
+			break;
+		}
+		if (elapsed < video.length) {
+			this._state.offset = elapsed;
+			this._state.key = key;
+			break;
+		} else {
+			elapsed -= video.length;
+			key = this.playlist.after(key);
+		}
+	}
+};
+
+Simulation.prototype._reschedule = function () {
+
+	clearTimeout(this._timeout);
+
+	var self = this;
+
+	function _notify () {
+		if (self._prev !== self._state.key) {
+			self._prev = self._state.key;
+			self.emit('state', self.getState());
+		}
+		self._reschedule();
+	}
+
+	function _schedule () {
+		var delay = self.playlist.get(self._state.key).length - self._state.offset;
+		self._timeout = setTimeout(_notify, Math.max(100, delay * 1000));
+	}
+
+	if (this._state.playing && this._state.key != null) {
+		_schedule();
+	}
+
+};
diff --git a/Synctube/lib/youtube.js b/Synctube/lib/youtube.js
new file mode 100644
index 0000000..8c25716
--- /dev/null
+++ b/Synctube/lib/youtube.js
@@ -0,0 +1,253 @@
+/**
+ * Module dependencies.
+ */
+
+var config = require('../config');
+var moment = require('moment');
+var pjson = require('../package');
+var request = require('request');
+var url = require('url');
+
+require('moment-interval');
+
+/**
+ * YouTube ID validation.
+ * See: http://markmail.org/message/jb6nsveqs7hya5la#query:+page:1+mid:jb6nsveqs7hya5la+state:results
+ */
+
+var validId = /^[a-zA-Z0-9_-]{11}$/;
+
+/**
+ * YouTube video search. Accepts arbitrary API options.
+ */
+
+function _search (opts, callback) {
+
+	opts.part = 'snippet';
+	opts.maxResults = 8;
+	opts.type = 'video';
+	opts.videoEmbeddable = true;
+	opts.key = config.youtube.apiKey;
+
+	request({
+		uri: 'https://www.googleapis.com/youtube/v3/search',
+		qs: opts,
+		headers: {
+			'User-Agent': pjson.name + '/' + pjson.version,
+		},
+		json: true,
+	}, function (err, res, body) {
+		err = err || body.error;
+		if (err) { callback(err); return; }
+
+		var items = body.items;
+		var prevToken = body.prevPageToken;
+		var nextToken = body.nextPageToken;
+
+		request({
+			uri: 'https://www.googleapis.com/youtube/v3/videos',
+			qs: {
+				part: 'contentDetails',
+				id: body.items.map(function (item) { return item.id.videoId; }).join(','),
+				key: config.youtube.apiKey,
+			},
+			headers: {
+				'User-Agent': pjson.name + '/' + pjson.version,
+			},
+			json: true,
+		}, function (err, res, body) {
+			err = err || body.error;
+			if (err) { callback(err); return; }
+
+			var lengths = {};
+			for (var i = 0; i < body.items.length; i++) {
+				var item = body.items[i];
+				lengths[item.id] = moment.duration(item.contentDetails.duration).asSeconds();
+			}
+
+			var obj = {
+				items: items.map(function (item) { return { item: item, length: lengths[item.id.videoId] }; }),
+				prevToken: prevToken,
+				nextToken: nextToken,
+			}
+
+			callback(null, obj);
+		});
+	});
+}
+
+/**
+ * Multi-video videos/list query.
+ */
+
+function _listVideos (ids, part, selector) {
+	var reqs = [];
+	Object.keys(ids).forEach(function (id) {
+		if (!validId.test(id)) {
+			var cb = ids[id];
+			process.nextTick(function () {
+				cb('Invalid video ID');
+			});
+			delete ids[id];
+		} else {
+			reqs.push(id);
+		}
+	});
+
+	request({
+		uri: 'https://www.googleapis.com/youtube/v3/videos',
+		qs: {
+			part: part,
+			id: reqs.join(','),
+			key: config.youtube.apiKey,
+		},
+		headers: {
+			'User-Agent': pjson.name + '/' + pjson.version,
+		},
+		json: true,
+	}, function (err, res, body) {
+		err = err || body.error;
+		if (err) {
+			Object.keys(ids).forEach(function (id) {
+				var cb = ids[id];
+				cb(err);
+			});
+			return;
+		}
+
+		body.items.forEach(function (item) {
+			var cb = ids[item.id];
+			if (cb) {
+				delete ids[item.id];
+				cb(null, selector(item));
+			}
+		});
+
+		for (id in ids) {
+			var cb = id[ids];
+			cb('Invalid video ID');
+		}
+	});
+}
+
+/**
+ * Utilities for batching requests.
+ */
+
+function _timeBatch (delay, max, func) {
+	var batch = [];
+	var timer = null;
+	return function () {
+		var args = [];
+		for (var i = 0; i < arguments.length; i++) {
+			args.push(arguments[i]);
+		}
+		batch.push(args);
+		if (batch.length == max) {
+			var _batch = batch;
+			batch = [];
+			process.nextTick(function () {
+				func(_batch);
+			});
+			return;
+		}
+		if (!timer) {
+			timer = setTimeout(function () {
+				var _batch = batch;
+				batch = [];
+				timer = null;
+				if (_batch.length == 0) { return; }
+				func(_batch);
+			}, delay);
+		}
+	};
+}
+
+function _groupCalls (reqs) {
+	var ids = {};
+	reqs.forEach(function (req) {
+		var id = req[0];
+		var cb = req[1];
+		var prev = ids[id];
+		if (prev) {
+			ids[id] = function (err, res) {
+				prev(err, res);
+				cb(err, res);
+			};
+		} else {
+			ids[id] = cb;
+		}		
+	});
+	return ids;
+}
+
+/**
+ * Module exports.
+ */
+
+module.exports = exports = {
+
+	/**
+	 * Gets video length (in seconds) for multiple videos. Keys are IDs, values are callbacks.
+	 */
+
+	getVideoLength: _timeBatch(config.youtube.batchDelay, config.youtube.batchLimit, function (reqs) {
+		var ids = _groupCalls(reqs);
+		_listVideos(ids, 'contentDetails', function (item) {
+			return moment.duration(item.contentDetails.duration).asSeconds();
+		});
+	}),
+
+	/**
+	 * Gets snippet for multiple videos. Keys are IDs, values are callbacks.
+	 */
+
+	getVideoSnippet: _timeBatch(config.youtube.batchDelay, config.youtube.batchLimit, function (reqs) {
+		var ids = _groupCalls(reqs);
+		_listVideos(ids, 'snippet', function (item) {
+			return item.snippet;
+		});
+	}),
+
+	/**
+	 * Gets video ID from YouTube URL.
+	 */
+
+	parseUrl: function (str) {
+		var parsed = url.parse(str, true);
+		if (parsed.hostname === 'youtu.be') {
+			var matches = parsed.pathname.match(/^\/([a-zA-Z0-9-_]{11})$/i);
+			if (matches) {
+				return matches[1];
+			}
+		} else if (parsed.hostname === 'www.youtube.com') {
+			if (parsed.pathname === '/watch' || parsed.pathname === '/') {
+				if (/^[a-zA-Z0-9-_]{11}$/i.test(parsed.query.v)) {
+					return parsed.query.v;
+				}
+			}
+			var matches = parsed.pathname.match(/^\/(?:v|e(?:mbed)?)\/([a-zA-Z0-9-_]{11})$/i);
+			if (matches) {
+				return matches[1];
+			}
+		}
+		return null;
+	},
+
+	/**
+	 * Searches for YouTube videos by string query.
+	 */
+
+	search: function (query, callback) {
+		_search({ q: query }, callback);
+	},
+
+	/**
+	 * Searches for YouTube videos by page token.
+	 */
+
+	searchPage: function (query, token, callback) {
+		_search({ q: query, pageToken: token }, callback);
+	},
+
+};
diff --git a/Synctube/package.json b/Synctube/package.json
new file mode 100644
index 0000000..1f8324f
--- /dev/null
+++ b/Synctube/package.json
@@ -0,0 +1,71 @@
+{
+    "name": "synctube",
+    "version": "0.2.4",
+    "description": "Realtime web video synchronization.",
+    "author": "Henry Merriam <henry@zephyrhosting.net>",
+    "main": "server",
+    "dependencies": {
+        "async": "^1.4.2",
+        "browser-request": "^0.3.3",
+        "domready": "^1.0.7",
+        "moment": "^2.5.1",
+        "moment-duration-format": "^1.3.0",
+        "moment-interval": "^0.2.1",
+        "mu2": "^0.5.20",
+        "redis": "^1.0.0",
+        "redis-scripto": "^0.1.3",
+        "redis-url": "^1.2.1",
+        "request": "^2.53.0",
+        "safesocket": "^1.0.0",
+        "socket.io": "^1.3.5",
+        "express": "^3.4.8"
+    },
+    "devDependencies": {
+        "bower": "^1.2.8",
+        "browserify": "^9.0.8",
+        "browserify-shim": "^3.8.5",
+        "envify": "^3.4.0",
+        "exorcist": "^0.3.0",
+        "less": "^2.5.0",
+        "less-plugin-clean-css": "^1.5.0",
+        "nodemon": "^1.3.7",
+        "uglify-js": "^2.4.20",
+        "parallelshell": "^1.1.1",
+        "watch": "^0.16.0"
+    },
+    "browserify": {
+        "transform": [
+            "envify",
+            "browserify-shim"
+        ]
+    },
+    "browser": {
+        "./config.js": "./config-client.js",
+        "request": "browser-request"
+    },
+    "browserify-shim": {
+        "jquery": "global:$",
+        "knockout": "global:ko",
+        "socket.io-client": "global:io"
+    },
+    "cacheDirectories": ["node_modules", "bower_components"],
+    "scripts": {
+        "start": "node .",
+        "build": "npm run build:css && npm run build:js && npm run build:min",
+        "build:css": "lessc --include-path=\"less:bower_components\" --clean-css less/main.less static/style.css",
+        "build:js": "npm run build:js:browse && npm run build:js:room",
+        "build:js:browse": "browserify client/browse.js --debug | exorcist static/browse.js.map > static/browse.js",
+        "build:js:room": "browserify client/room.js --debug | exorcist static/room.js.map > static/room.js",
+        "build:min": "npm run build:min:browse && npm run build:min:room",
+        "build:min:browse": "uglifyjs static/browse.js -m -c --source-map static/browse.min.js.map --in-source-map static/browse.js.map --source-map-url browse.min.js.map > static/browse.min.js",
+        "build:min:room": "uglifyjs static/room.js -m -c --source-map static/room.min.js.map --in-source-map static/room.js.map --source-map-url room.min.js.map > static/room.min.js",
+        "watch": "parallelshell \"npm run watch:css\" \"npm run watch:js\"",
+        "watch:css": "watch \"npm run build:css\" less/",
+        "watch:js": "watch \"npm run build:js && npm run build:min\" lib/ client/",
+        "nodemon": "nodemon --watch lib --watch server --watch server.js --watch template --ext js,html server.js",
+        "dev": "parallelshell \"npm run watch\" \"npm run nodemon\"",
+        "postinstall": "bower install && npm run build"
+    },
+    "engines": { "node": "^0.10.36" },
+    "private": true
+}
diff --git a/Synctube/server.js b/Synctube/server.js
new file mode 100644
index 0000000..2a67085
--- /dev/null
+++ b/Synctube/server.js
@@ -0,0 +1,60 @@
+var express = require('express');
+var app = express();
+var mu = require('mu2');
+
+var config = require('./config');
+var sockets = require('./server/sockets');
+var datastore = require('./server/datastore');
+
+var clientVersion = require('socket.io/node_modules/socket.io-client/package').version;
+
+require('./server/sync');
+
+mu.root = __dirname + '/template';
+
+function render(res, file, data) {
+	if (app.settings.env === 'development') {
+		mu.clearCache(file);
+	}
+	mu.compileAndRender(file, data).pipe(res);
+}
+
+app.get('/', function (req, res) {
+	datastore.getTopRooms(function (err, rooms) {
+		if (err) {
+			res.status(500);
+			res.send('error');
+			return;
+		}
+		var data = {
+			rooms: rooms.map(function (room) {
+				return {
+					name: room.name,
+					encoded: encodeURIComponent(room.name),
+					connected: room.count,
+				};
+			}),
+			socketioClientVersion: clientVersion,
+		};
+		res.format({
+			json: function (req, res) {
+				res.json(data);
+			},
+			html: function (req, res) {
+				render(res, 'index.html', data);
+			},
+		});
+	});
+});
+
+app.get('/rooms/:name', function (req, res) {
+	res.writeHead(200, { 'Content-Type': 'text/html; charset=utf8' });
+	render(res, 'room.html', {
+		socketioClientVersion: clientVersion,
+	});
+});
+
+app.use(express.static(__dirname + '/static'));
+
+var server = app.listen(config.listen.port);
+sockets.listen(server);
diff --git a/Synctube/server/datastore.js b/Synctube/server/datastore.js
new file mode 100644
index 0000000..8dcca18
--- /dev/null
+++ b/Synctube/server/datastore.js
@@ -0,0 +1,218 @@
+/**
+ * Module dependencies.
+ */
+
+var async = require('async');
+var redis = require('redis-url');
+var Scripto = require('redis-scripto');
+var EventEmitter = require('events').EventEmitter;
+var util = require('util');
+
+/**
+ * Datastore constructor.
+ */
+
+function Datastore () {
+	EventEmitter.call(this);
+};
+
+util.inherits(Datastore, EventEmitter);
+
+/**
+ * Module exports.
+ */
+
+var datastore = module.exports = exports = new Datastore();
+
+/**
+ * Scripting client.
+ */
+
+var client = redis.connect();
+var scripts = new Scripto(client);
+scripts.loadFromDir(__dirname + '/scripts/');
+
+/**
+ * Events.
+ */
+
+var subscriber = redis.connect();
+subscriber.on('ready', function () {
+	subscriber.on('message', function (channel, message) {
+		var obj = JSON.parse(message);
+		if (channel == 'events') {
+			datastore.emit('room', obj.room, obj.event, obj.args);
+		} else if (channel == 'users') {
+			datastore.emit('users', obj.room, obj.count);
+		}
+	});
+	subscriber.subscribe(eventsChannel);
+	subscriber.subscribe('users');
+});
+
+/**
+ * Methods.
+ */
+
+Datastore.prototype.addVideo = function (room, video, cb) {
+	scripts.run('hashlist', getKeys(room), [eventsChannel, room, 'add', getTime(), JSON.stringify(video)], wrap(cb));
+};
+
+Datastore.prototype.deleteVideo = function (room, key, cb) {
+	scripts.run('hashlist', getKeys(room), [eventsChannel, room, 'del', getTime(), key], wrap(cb));
+};
+
+Datastore.prototype.moveVideo = function (room, key, before, cb) {
+	scripts.run('hashlist', getKeys(room), [eventsChannel, room, 'move', getTime(), key, before], wrap(cb));
+};
+
+Datastore.prototype.playVideo = function (room, key, cb) {
+	scripts.run('hashlist', getKeys(room), [eventsChannel, room, 'play', getTime(), key], wrap(cb));
+};
+
+Datastore.prototype.shufflePlaylist = function (room, cb) {
+	scripts.run('hashlist', getKeys(room), [eventsChannel, room, 'shuffle', getTime()], wrap(cb));
+};
+
+Datastore.prototype.setPlaying = function (room, playing, cb) {
+	scripts.run('hashlist', getKeys(room), [eventsChannel, room, 'setPlaying', getTime(), playing? 1 : 0], wrap(cb));
+};
+
+Datastore.prototype.setOffset = function (room, offset, cb) {
+	scripts.run('hashlist', getKeys(room), [eventsChannel, room, 'setOffset', getTime(), offset], wrap(cb));
+};
+
+Datastore.prototype.getPlaylist = function (room, cb) {
+	scripts.run('hashlist', getKeys(room), [eventsChannel, room, 'list', getTime()], wrap(cb));
+};
+
+Datastore.prototype.getState = function (room, cb) {
+	scripts.run('hashlist', getKeys(room), [eventsChannel, room, 'state', getTime()], wrap(cb));
+};
+
+Datastore.prototype.deleteRoom = function (room, cb) {
+	scripts.run('hashlist', getKeys(room), [eventsChannel, room, 'deleteRoom', getTime()], wrap(cb));
+};
+
+/**
+ * Timekeeping.
+ */
+
+function getTime () {
+	return (Date.now() / 1000).toString();
+}
+
+/**
+ * Redis keys.
+ */
+
+function getKeys (room) {
+	return [
+		'counter',
+		'room:' + room + ':nodes',
+		'room:' + room + ':state',
+		'room:' + room + ':length',
+	];
+}
+
+var eventsChannel = 'events';
+
+/**
+ * Common callback wrapper.
+ */
+
+function wrap (cb) {
+	if (!cb) { cb = function () {}; }
+	return function (err, result) {
+		if (err) { console.warn(err); return cb(err); }
+		return cb(null, JSON.parse(result));
+	};
+}
+
+/**
+ * Server heartbeat.
+ */
+
+var _id = null;
+
+function heartbeat () {
+	scripts.run('heartbeat', ['servers:counter', 'servers:timeouts'], [getTime(), _id], wrap(function (err, result) {
+		if (err) { return; }
+		_id = result.id;
+		if (result.dead) {
+			result.dead.forEach(function (dead) {
+				scripts.run('dead', ['server:' + dead + ':rooms', 'rooms:counts', 'rooms:timeouts', 'servers:timeouts'], [getTime(), dead], wrap());
+			});
+		}
+	}));
+}
+
+heartbeat();
+setInterval(heartbeat, 30 * 1000);
+
+/**
+ * Rooms.
+ */
+
+Datastore.prototype.getTopRooms = function (cb) {
+	scripts.run('browse', [
+		'rooms:counts',
+		'rooms:timeouts',
+		'rooms:expired'
+	], [getTime()], wrap(cb));
+};
+
+Datastore.prototype.join = function (room, cb) {
+	scripts.run('join', [
+		'server:' + _id + ':rooms',
+		'rooms:counts',
+		'rooms:timeouts',
+		'rooms:expired',
+		'room:' + room + ':nodes',
+		'room:' + room + ':state',
+		'room:' + room + ':length'
+	], [room, getTime()], wrap(cb));
+};
+
+Datastore.prototype.leave = function (room, cb) {
+	scripts.run('leave', [
+		'server:' + _id + ':rooms',
+		'rooms:counts',
+		'rooms:timeouts',
+	], [room, getTime()], wrap(cb));
+};
+
+Datastore.prototype.getUserCount = function (room, cb) {
+	client.zscore('rooms:counts', room, wrap(cb));
+};
+
+/**
+ * Garbage collection.
+ */
+
+function collect () {
+	var _room;
+	async.doDuring(function (cb) {
+		client.srandmember('rooms:expired', function (err, room) {
+			if (err) { return cb(err); }
+			_room = room;
+			cb(null);
+		});
+	}, function (cb) {
+		scripts.run('collect', [
+			'rooms:expired',
+			'room:' + _room + ':nodes',
+			'room:' + _room + ':state',
+			'room:' + _room + ':length',
+		], [_room], function (err) {
+			if (err) { return cb(err); }
+			return cb(null, _room != null);
+		});
+	}, function (err) {
+		if (err) {
+			console.warn(err);
+		}
+	});
+}
+
+setInterval(collect, 10 * 60 * 1000);
diff --git a/Synctube/server/scripts/browse.lua b/Synctube/server/scripts/browse.lua
new file mode 100644
index 0000000..1f841aa
--- /dev/null
+++ b/Synctube/server/scripts/browse.lua
@@ -0,0 +1,27 @@
+local roomCountsKey = KEYS[1]
+local roomTimeoutsKey = KEYS[2]
+local roomExpiredKey = KEYS[3]
+
+local time = tonumber(ARGV[1])
+
+local timeout = time - (30 * 60)
+local expired = redis.call('ZRANGEBYSCORE', roomTimeoutsKey, '-inf', timeout)
+redis.call('ZREMRANGEBYSCORE', roomTimeoutsKey, '-inf', timeout)
+
+for _, r in ipairs(expired) do
+  redis.call('ZREM', roomCountsKey, r)
+  redis.call('SADD', roomExpiredKey, r)
+end
+
+local rooms = redis.call('ZREVRANGE', roomCountsKey, 0, 9, 'WITHSCORES')
+
+local result = {}
+for idx = 1, #rooms, 2 do
+  result[#result + 1] = {name=rooms[idx],count=tonumber(rooms[idx + 1])}
+end
+
+if #result > 0 then
+  return cjson.encode(result)
+else
+  return '[]'
+end
diff --git a/Synctube/server/scripts/collect.lua b/Synctube/server/scripts/collect.lua
new file mode 100644
index 0000000..fb20ed0
--- /dev/null
+++ b/Synctube/server/scripts/collect.lua
@@ -0,0 +1,11 @@
+local roomExpiredKey = KEYS[1]
+
+local nodesKey = KEYS[2]
+local stateKey = KEYS[3]
+local lengthKey = KEYS[4]
+
+local room = ARGV[1]
+
+if redis.call('SREM', roomExpiredKey, room) == 1 then
+  redis.call('DEL', nodesKey, stateKey, lengthKey)
+end
diff --git a/Synctube/server/scripts/dead.lua b/Synctube/server/scripts/dead.lua
new file mode 100644
index 0000000..4c43d64
--- /dev/null
+++ b/Synctube/server/scripts/dead.lua
@@ -0,0 +1,27 @@
+local serverRoomsKey = KEYS[1]
+local roomCountsKey = KEYS[2]
+local roomTimeoutsKey = KEYS[3]
+local serversKey = KEYS[4]
+
+local time = tonumber(ARGV[1])
+local dead = ARGV[2]
+
+redis.call('ZUNIONSTORE', roomCountsKey, 2, roomCountsKey, serverRoomsKey, 'WEIGHTS', 1, -1)
+
+redis.call('ZINTERSTORE', serverRoomsKey, 2, roomCountsKey, serverRoomsKey, 'WEIGHTS', 1, 0)
+local changed = redis.call('ZRANGE', serverRoomsKey, 0, -1, 'WITHSCORES')
+
+for idx = 1, #changed, 2 do
+  local room = changed[idx]
+  local count = changed[idx + 1]
+  redis.call('PUBLISH', 'users', cjson.encode({room=room,count=tonumber(count)}))
+end
+
+redis.call('DEL', serverRoomsKey)
+redis.call('ZREM', serversKey, dead)
+
+local empty = redis.call('ZRANGEBYSCORE', roomCountsKey, '-inf', 0)
+
+for _, room in ipairs(empty) do
+  redis.call('ZADD', roomTimeoutsKey, time, room)
+end
diff --git a/Synctube/server/scripts/hashlist.lua b/Synctube/server/scripts/hashlist.lua
new file mode 100644
index 0000000..052ced8
--- /dev/null
+++ b/Synctube/server/scripts/hashlist.lua
@@ -0,0 +1,343 @@
+--------------------------
+-- Redis key parameters --
+--------------------------
+
+local _counterKey = KEYS[1]
+local _nodesKey = KEYS[2]
+local _stateKey = KEYS[3]
+local _lengthKey = KEYS[4]
+local _eventChannel = ARGV[1]
+local _room = ARGV[2]
+
+----------------------------
+-- Redis access functions --
+----------------------------
+
+local _getNode = function (key)
+  local enc = redis.call('HGET', _nodesKey, key)
+  if not enc then
+    return {h=0,t=0}
+  end
+  return cmsgpack.unpack(enc)
+end
+
+local _setNode = function (key, node)
+  local enc = cmsgpack.pack(node)
+  redis.call('HSET', _nodesKey, key, enc)
+end
+
+local _deleteNode = function (key)
+  redis.call('HDEL', _nodesKey, key)
+end
+
+local _getNextKey = function ()
+  return tonumber(redis.call('INCR', _counterKey))
+end
+
+--------------------------------
+-- Internal utility functions --
+--------------------------------
+
+local _extract = function (key)
+  local node = _getNode(key)
+  local head = _getNode(node.h)
+  head.t = node.t
+  _setNode(node.h, head)
+  local tail = _getNode(node.t)
+  tail.h = node.h
+  _setNode(node.t, tail)
+  return node.v
+end
+
+-------------------
+-- API functions --
+-------------------
+
+local getValue = function (key)
+  local node = _getNode(key)
+  return node.v
+end
+
+-- Iterates the list.
+--
+-- If `start` is 0 or nil, iteration begins with the first element
+-- If `start` is given, iteration will start at the element with that key (inclusive)
+-- If `start` is not a valid key, behavior is undefined (TODO)
+--
+-- If `stop` is 0 or nil, iteration stops at the end of the list
+-- If `stop` is given, iteration will end before the element with that key (exclusive)
+-- If `stop` is an element that comes before the start, iteration will silently wrap around to the beginning of the list
+-- If `stop` is not a valid key, iteration loops forever
+
+local iterate = function (start, stop)
+  local key = start or 0
+  stop = stop or 0
+  return function ()
+    if not key then return end
+    if key == 0 then
+      key = _getNode(0).h
+    end
+    if key ~= 0 then
+      local cur = key
+      local node = _getNode(cur)
+      key = node.h
+      if key == stop then
+        key = nil
+      end
+      return node.v, cur
+    end
+  end
+end
+
+local getAll = function ()
+  local t = {}
+  for v, k in iterate() do
+    t[#t + 1] = {key=k,value=v}
+  end
+  return t
+end
+
+local getKeys = function ()
+  local t = {}
+  for _, k in iterate() do
+    t[#t + 1] = k
+  end
+  return t
+end
+
+local insert = function (key, value, before)
+  local head = _getNode(before)
+  local node = {v=value,h=before,t=head.t}
+  head.t = key
+  _setNode(node.h, head)
+  local tail = _getNode(node.t)
+  tail.h = key
+  _setNode(node.t, tail)
+  _setNode(key, node)
+end
+
+local delete = function (key)
+  _extract(key)
+  _deleteNode(key)
+end
+
+local move = function (key, before)
+  local value = _extract(key)
+  insert(key, value, before)
+  redis.call('PUBLISH', _eventChannel, cjson.encode({room=_room,event='move',args={key,before}}))
+end
+
+local push = function (value)
+  local key = _getNextKey()
+  insert(key, value, 0)
+  return key
+end
+
+---------------------------------
+-- Playlist handling functions --
+---------------------------------
+
+local getState = function ()
+  local enc = redis.call('GET', _stateKey)
+  if enc then
+    return cmsgpack.unpack(enc)
+  else
+    return {
+      time = 0,
+      key = nil,
+      playing = false,
+      offset = 0
+    }
+  end
+end
+
+local formatState = function (state)
+  local f = {}
+  if state.key ~= 0 then
+    f.key = state.key
+  else
+    f.key = nil
+  end
+  f.playing = state.playing
+  f.offset = state.offset
+  return f
+end
+
+local setState = function (state, notify)
+  redis.call('SET', _stateKey, cmsgpack.pack(state))
+  if notify then
+    redis.call('PUBLISH', _eventChannel, cjson.encode({room=_room,event='state',args={formatState(state)}}))
+  end
+end
+
+local getLength = function ()
+  return tonumber(redis.call('GET', _lengthKey)) or 0
+end
+
+local addLength = function (length)
+  redis.call('INCRBYFLOAT', _lengthKey, length)
+end
+
+local updateState = function (time)
+
+  local state = getState()
+
+  if time < state.time then
+    -- TODO: Error, or just let it go?
+    -- Maybe write a warning to a logging queue?
+    time = state.time
+  end
+
+  local elapsed = time - state.time
+  state.time = time
+
+  if not state.playing then
+    return state
+  end
+
+  elapsed = (elapsed + state.offset) % getLength()
+  for v, k in iterate(state.key, state.key) do
+    if elapsed < v.length then
+      state.offset = elapsed
+      state.key = k
+      return state
+    else
+      elapsed = elapsed - v.length
+    end
+  end
+
+  state.key = nil
+  state.playing = false
+  state.offset = 0
+
+  return state -- TODO: Maybe warn on this condition?
+
+end
+
+local play = function (time, key)
+  setState({
+    time = time,
+    key = key,
+    playing = true,
+    offset = 0
+  }, true)
+end
+
+local setPlaying = function (time, playing)
+  local state = updateState(time)
+  if playing and (state.key == nil) then
+    state.key = _getNode(0).h
+    if state.key == nil then
+      setState(state)
+      return false 
+    end
+  end
+  state.playing = playing
+  setState(state, true)
+  return true
+end
+
+local setOffset = function (time, offset)
+  local state = updateState(time)
+  state.offset = offset
+  setState(state, true)
+end
+
+local _knuthShuffle = function (t)
+  local n = #t
+  while n > 1 do
+    local k = math.random(n)
+    t[n], t[k] = t[k], t[n]
+    n = n - 1
+  end
+  return t
+end
+
+local shuffle = function (time, seed)
+  local state = updateState(time)
+  math.randomseed(seed)
+  for _, k in ipairs(_knuthShuffle(getKeys())) do
+    move(k, 0)
+  end
+  setState(state, true)
+end
+
+local addVideo = function (time, video)
+  local state = updateState(time)
+  addLength(video.length)
+  local key = push(video)
+  redis.call('PUBLISH', _eventChannel, cjson.encode({room=_room,event='put',args={key,video}}))
+  setState(state, true)
+end
+
+local delVideo = function (time, key)
+  local state = updateState(time)
+  local video = getValue(key)
+  addLength(-video.length)
+  delete(key)
+  redis.call('PUBLISH', _eventChannel, cjson.encode({room=_room,event='remove',args={key}}))
+  if state.key == key then
+    state.playing = false
+    state.key = nil
+    state.offset = 0
+  end
+  setState(state, true)
+end
+
+local moveVideo = function (time, key, before)
+  local state = updateState(time)
+  move(key, before)
+  setState(state, true)
+end
+
+-------------------------------
+-- Room expiration functions --
+-------------------------------
+
+local deleteRoom = function ()
+  redis.call('DEL', _nodesKey)
+  redis.call('DEL', _stateKey)
+  redis.call('DEL', _lengthKey)
+end
+
+--------------------
+-- Function calls --
+--------------------
+
+local call = ARGV[3]
+local time = tonumber(ARGV[4])
+local arg1 = ARGV[5]
+local arg2 = ARGV[6]
+
+if call == "add" then
+  addVideo(time, cjson.decode(arg1))
+elseif call == "del" then
+  delVideo(time, tonumber(arg1))
+elseif call == "move" then
+  moveVideo(time, tonumber(arg1), tonumber(arg2))
+elseif call == "play" then
+  play(time, tonumber(arg1))
+elseif call == "shuffle" then
+  shuffle(time, time * 1000)
+elseif call == "setPlaying" then
+  setPlaying(time, tonumber(arg1) ~= 0)
+elseif call == "setOffset" then
+  setOffset(time, tonumber(arg1))
+elseif call == "list" then
+  local list = getAll()
+  if #list == 0 then return "[]" end
+  return cjson.encode(